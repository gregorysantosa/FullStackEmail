{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n  return to;\n};\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeClientRequest = void 0;\nvar http_1 = require(\"http\");\nvar until_1 = require(\"@open-draft/until\");\nvar headers_polyfill_1 = require(\"headers-polyfill\");\nvar concatChunkToBuffer_1 = require(\"./utils/concatChunkToBuffer\");\nvar normalizeClientRequestEndArgs_1 = require(\"./utils/normalizeClientRequestEndArgs\");\nvar toIsoResponse_1 = require(\"../../utils/toIsoResponse\");\nvar getIncomingMessageBody_1 = require(\"./utils/getIncomingMessageBody\");\nvar bodyBufferToString_1 = require(\"./utils/bodyBufferToString\");\nvar normalizeClientRequestWriteArgs_1 = require(\"./utils/normalizeClientRequestWriteArgs\");\nvar cloneIncomingMessage_1 = require(\"./utils/cloneIncomingMessage\");\nvar IsomorphicRequest_1 = require(\"../../IsomorphicRequest\");\nvar InteractiveIsomorphicRequest_1 = require(\"../../InteractiveIsomorphicRequest\");\nvar bufferUtils_1 = require(\"../../utils/bufferUtils\");\nvar NodeClientRequest = /** @class */function (_super) {\n  __extends(NodeClientRequest, _super);\n  function NodeClientRequest(_a, options) {\n    var _b = __read(_a, 3),\n      url = _b[0],\n      requestOptions = _b[1],\n      callback = _b[2];\n    var _this = _super.call(this, requestOptions, callback) || this;\n    _this.chunks = [];\n    _this.responseSource = 'mock';\n    _this.requestBody = [];\n    _this.log = options.log.extend(\"request \" + requestOptions.method + \" \" + url.href);\n    _this.log('constructing ClientRequest using options:', {\n      url: url,\n      requestOptions: requestOptions,\n      callback: callback\n    });\n    _this.url = url;\n    _this.options = requestOptions;\n    _this.emitter = options.emitter;\n    // Construct a mocked response message.\n    _this.response = new http_1.IncomingMessage(_this.socket);\n    return _this;\n  }\n  NodeClientRequest.prototype.write = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var _a = __read(normalizeClientRequestWriteArgs_1.normalizeClientRequestWriteArgs(args), 3),\n      chunk = _a[0],\n      encoding = _a[1],\n      callback = _a[2];\n    this.log('write:', {\n      chunk: chunk,\n      encoding: encoding,\n      callback: callback\n    });\n    this.chunks.push({\n      chunk: chunk,\n      encoding: encoding\n    });\n    this.requestBody = concatChunkToBuffer_1.concatChunkToBuffer(chunk, this.requestBody);\n    this.log('chunk successfully stored!', this.requestBody);\n    /**\n     * Prevent invoking the callback if the written chunk is empty.\n     * @see https://nodejs.org/api/http.html#requestwritechunk-encoding-callback\n     */\n    if (!chunk || chunk.length === 0) {\n      this.log('written chunk is empty, skipping callback...');\n    } else {\n      callback === null || callback === void 0 ? void 0 : callback();\n    }\n    // Do not write the request body chunks to prevent\n    // the Socket from sending data to a potentially existing\n    // server when there is a mocked response defined.\n    return true;\n  };\n  NodeClientRequest.prototype.end = function () {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    this.log('end', args);\n    var _a = __read(normalizeClientRequestEndArgs_1.normalizeClientRequestEndArgs.apply(void 0, __spreadArray([], __read(args))), 3),\n      chunk = _a[0],\n      encoding = _a[1],\n      callback = _a[2];\n    this.log('normalized arguments:', {\n      chunk: chunk,\n      encoding: encoding,\n      callback: callback\n    });\n    var requestBody = this.getRequestBody(chunk);\n    var isomorphicRequest = this.toIsomorphicRequest(requestBody);\n    var interactiveIsomorphicRequest = new InteractiveIsomorphicRequest_1.InteractiveIsomorphicRequest(isomorphicRequest);\n    // Notify the interceptor about the request.\n    // This will call any \"request\" listeners the users have.\n    this.log('emitting the \"request\" event for %d listener(s)...', this.emitter.listenerCount('request'));\n    this.emitter.emit('request', interactiveIsomorphicRequest);\n    // Execute the resolver Promise like a side-effect.\n    // Node.js 16 forces \"ClientRequest.end\" to be synchronous and return \"this\".\n    until_1.until(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a, mockedResponse;\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              return [4 /*yield*/, this.emitter.untilIdle('request', function (_a) {\n                var _b = __read(_a.args, 1),\n                  request = _b[0];\n                /**\n                 * @note Await only those listeners that are relevant to this request.\n                 * This prevents extraneous parallel request from blocking the resolution\n                 * of another, unrelated request. For example, during response patching,\n                 * when request resolution is nested.\n                 */\n                return request.id === interactiveIsomorphicRequest.id;\n              })];\n            case 1:\n              _b.sent();\n              return [4 /*yield*/, interactiveIsomorphicRequest.respondWith.invoked()];\n            case 2:\n              _a = __read.apply(void 0, [_b.sent(), 1]), mockedResponse = _a[0];\n              this.log('event.respondWith called with:', mockedResponse);\n              return [2 /*return*/, mockedResponse];\n          }\n        });\n      });\n    }).then(function (_a) {\n      var e_1, _b;\n      var _c = __read(_a, 2),\n        resolverException = _c[0],\n        mockedResponse = _c[1];\n      _this.log('the listeners promise awaited!');\n      // Halt the request whenever the resolver throws an exception.\n      if (resolverException) {\n        _this.log('encountered resolver exception, aborting request...', resolverException);\n        _this.emit('error', resolverException);\n        _this.terminate();\n        return _this;\n      }\n      if (mockedResponse) {\n        _this.log('received mocked response:', mockedResponse);\n        _this.responseSource = 'mock';\n        var isomorphicResponse = toIsoResponse_1.toIsoResponse(mockedResponse);\n        _this.respondWith(mockedResponse);\n        _this.log(isomorphicResponse.status, isomorphicResponse.statusText, isomorphicResponse.body, '(MOCKED)');\n        callback === null || callback === void 0 ? void 0 : callback();\n        _this.log('emitting the custom \"response\" event...');\n        _this.emitter.emit('response', isomorphicRequest, isomorphicResponse);\n        return _this;\n      }\n      _this.log('no mocked response received!');\n      // Set the response source to \"bypass\".\n      // Any errors emitted past this point are not suppressed.\n      _this.responseSource = 'bypass';\n      // Propagate previously captured errors.\n      // For example, a ECONNREFUSED error when connecting to a non-existing host.\n      if (_this.capturedError) {\n        _this.emit('error', _this.capturedError);\n        return _this;\n      }\n      // Write the request body chunks in the order of \".write()\" calls.\n      // Note that no request body has been written prior to this point\n      // in order to prevent the Socket to communicate with a potentially\n      // existing server.\n      _this.log('writing request chunks...', _this.chunks);\n      try {\n        for (var _d = __values(_this.chunks), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var _f = _e.value,\n            chunk_1 = _f.chunk,\n            encoding_1 = _f.encoding;\n          if (encoding_1) {\n            _super.prototype.write.call(_this, chunk_1, encoding_1);\n          } else {\n            _super.prototype.write.call(_this, chunk_1);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      _this.once('error', function (error) {\n        _this.log('original request error:', error);\n      });\n      _this.once('abort', function () {\n        _this.log('original request aborted!');\n      });\n      _this.once('response-internal', function (response) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var responseBody;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4 /*yield*/, getIncomingMessageBody_1.getIncomingMessageBody(response)];\n              case 1:\n                responseBody = _a.sent();\n                this.log(response.statusCode, response.statusMessage, responseBody);\n                this.log('original response headers:', response.headers);\n                this.log('emitting the custom \"response\" event...');\n                this.emitter.emit('response', isomorphicRequest, {\n                  status: response.statusCode || 200,\n                  statusText: response.statusMessage || 'OK',\n                  headers: headers_polyfill_1.objectToHeaders(response.headers),\n                  body: responseBody\n                });\n                return [2 /*return*/];\n            }\n          });\n        });\n      });\n\n      _this.log('performing original request...');\n      return _super.prototype.end.apply(_this, __spreadArray([], __read([chunk, encoding, function () {\n        _this.log('original request end!');\n        callback === null || callback === void 0 ? void 0 : callback();\n      }].filter(Boolean))));\n    });\n    return this;\n  };\n  NodeClientRequest.prototype.emit = function (event) {\n    var data = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      data[_i - 1] = arguments[_i];\n    }\n    this.log('event:%s', event);\n    if (event === 'response') {\n      this.log('found \"response\" event, cloning the response...');\n      try {\n        /**\n         * Clone the response object when emitting the \"response\" event.\n         * This prevents the response body stream from locking\n         * and allows reading it twice:\n         * 1. Internal \"response\" event from the observer.\n         * 2. Any external response body listeners.\n         * @see https://github.com/mswjs/interceptors/issues/161\n         */\n        var response = data[0];\n        var firstClone = cloneIncomingMessage_1.cloneIncomingMessage(response);\n        var secondClone = cloneIncomingMessage_1.cloneIncomingMessage(response);\n        this.emit('response-internal', secondClone);\n        this.log('response successfully cloned, emitting \"response\" event...');\n        return _super.prototype.emit.apply(this, __spreadArray([event, firstClone], __read(data.slice(1))));\n      } catch (error) {\n        this.log('error when cloning response:', error);\n        return _super.prototype.emit.apply(this, __spreadArray([event], __read(data)));\n      }\n    }\n    if (event === 'error') {\n      var error = data[0];\n      var errorCode = error.code || '';\n      this.log('error:\\n', error);\n      // Suppress certain errors while using the \"mock\" source.\n      // For example, no need to destroy this request if it connects\n      // to a non-existing hostname but has a mocked response.\n      if (this.responseSource === 'mock' && NodeClientRequest.suppressErrorCodes.includes(errorCode)) {\n        // Capture the first emitted error in order to replay\n        // it later if this request won't have any mocked response.\n        if (!this.capturedError) {\n          this.capturedError = error;\n          this.log('captured the first error:', this.capturedError);\n        }\n        return false;\n      }\n    }\n    return _super.prototype.emit.apply(this, __spreadArray([event], __read(data)));\n  };\n  NodeClientRequest.prototype.respondWith = function (mockedResponse) {\n    var e_2, _a, _b;\n    this.log('responding with a mocked response...', mockedResponse);\n    var status = mockedResponse.status,\n      statusText = mockedResponse.statusText,\n      headers = mockedResponse.headers,\n      body = mockedResponse.body;\n    this.response.statusCode = status;\n    this.response.statusMessage = statusText;\n    if (headers) {\n      this.response.headers = {};\n      try {\n        for (var _c = __values(Object.entries(headers)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var _e = __read(_d.value, 2),\n            headerName = _e[0],\n            headerValue = _e[1];\n          (_b = this.response.rawHeaders).push.apply(_b, __spreadArray([headerName], __read(Array.isArray(headerValue) ? headerValue : [headerValue])));\n          var insensitiveHeaderName = headerName.toLowerCase();\n          var prevHeaders = this.response.headers[insensitiveHeaderName];\n          this.response.headers[insensitiveHeaderName] = prevHeaders ? Array.prototype.concat([], prevHeaders, headerValue) : headerValue;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n    this.log('mocked response headers ready:', headers);\n    if (body) {\n      this.response.push(Buffer.from(body));\n    }\n    // Push \"null\" to indicate that the response body is complete\n    // and shouldn't be written to anymore.\n    this.response.push(null);\n    this.response.complete = true;\n    /**\n     * Set the internal \"res\" property to the mocked \"OutgoingMessage\"\n     * to make the \"ClientRequest\" instance think there's data received\n     * from the socket.\n     * @see https://github.com/nodejs/node/blob/9c405f2591f5833d0247ed0fafdcd68c5b14ce7a/lib/_http_client.js#L501\n     */\n    // @ts-ignore\n    this.res = this.response;\n    this.finished = true;\n    Object.defineProperty(this, 'writableEnded', {\n      value: true\n    });\n    this.emit('finish');\n    this.emit('response', this.response);\n    this.terminate();\n  };\n  /**\n   * Terminates a pending request.\n   */\n  NodeClientRequest.prototype.terminate = function () {\n    // @ts-ignore\n    this.agent.destroy();\n  };\n  NodeClientRequest.prototype.getRequestBody = function (chunk) {\n    var writtenRequestBody = bodyBufferToString_1.bodyBufferToString(Buffer.concat(this.requestBody));\n    this.log('written request body:', writtenRequestBody);\n    // Write the last request body chunk to the internal request body buffer.\n    if (chunk) {\n      this.requestBody = concatChunkToBuffer_1.concatChunkToBuffer(chunk, this.requestBody);\n    }\n    var resolvedRequestBody = Buffer.concat(this.requestBody);\n    this.log('resolved request body:', resolvedRequestBody);\n    return bufferUtils_1.getArrayBuffer(resolvedRequestBody);\n  };\n  NodeClientRequest.prototype.toIsomorphicRequest = function (body) {\n    var e_3, _a;\n    this.log('creating isomorphic request object...');\n    var outgoingHeaders = this.getHeaders();\n    this.log('request outgoing headers:', outgoingHeaders);\n    var headers = new headers_polyfill_1.Headers();\n    try {\n      for (var _b = __values(Object.entries(outgoingHeaders)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n          headerName = _d[0],\n          headerValue = _d[1];\n        if (!headerValue) {\n          continue;\n        }\n        headers.set(headerName.toLowerCase(), headerValue.toString());\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    var isomorphicRequest = new IsomorphicRequest_1.IsomorphicRequest(this.url, {\n      body: body,\n      method: this.options.method || 'GET',\n      credentials: 'same-origin',\n      headers: headers\n    });\n    this.log('successfully created isomorphic request!', isomorphicRequest);\n    return isomorphicRequest;\n  };\n  /**\n   * The list of internal Node.js errors to suppress while\n   * using the \"mock\" response source.\n   */\n  NodeClientRequest.suppressErrorCodes = ['ENOTFOUND', 'ECONNREFUSED', 'ECONNRESET', 'EAI_AGAIN'];\n  return NodeClientRequest;\n}(http_1.ClientRequest);\nexports.NodeClientRequest = NodeClientRequest;","map":{"version":3,"mappings":"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","names":["__extends","_a","options","_b","url","requestOptions","callback","_super","_this","log","extend","method","href","emitter","response","http_1","socket","NodeClientRequest","_i","args","normalizeClientRequestWriteArgs_1","chunk","encoding","chunks","push","requestBody","concatChunkToBuffer_1","length","normalizeClientRequestEndArgs_1","getRequestBody","isomorphicRequest","toIsomorphicRequest","interactiveIsomorphicRequest","InteractiveIsomorphicRequest_1","listenerCount","emit","until_1","untilIdle","request","id","respondWith","invoked","mockedResponse","then","_c","resolverException","terminate","responseSource","isomorphicResponse","toIsoResponse_1","status","statusText","body","capturedError","chunk_1","encoding_1","write","once","error","getIncomingMessageBody_1","responseBody","statusCode","statusMessage","headers","headers_polyfill_1","end","filter","Boolean","event","data","firstClone","cloneIncomingMessage_1","secondClone","slice","errorCode","code","suppressErrorCodes","includes","entries","headerName","headerValue","rawHeaders","Array","isArray","insensitiveHeaderName","toLowerCase","prevHeaders","prototype","concat","Buffer","from","complete","res","finished","Object","defineProperty","value","agent","destroy","writtenRequestBody","bodyBufferToString_1","resolvedRequestBody","bufferUtils_1","outgoingHeaders","getHeaders","set","toString","IsomorphicRequest_1","credentials","exports"],"sources":["C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\ClientRequest\\NodeClientRequest.ts"],"sourcesContent":["import type { Debugger } from 'debug'\nimport type { RequestOptions } from 'http'\nimport { ClientRequest, IncomingMessage } from 'http'\nimport { until } from '@open-draft/until'\nimport { Headers, objectToHeaders } from 'headers-polyfill'\nimport { MockedResponse } from '../../glossary'\nimport type { ClientRequestEmitter } from '.'\nimport { concatChunkToBuffer } from './utils/concatChunkToBuffer'\nimport {\n  ClientRequestEndChunk,\n  normalizeClientRequestEndArgs,\n} from './utils/normalizeClientRequestEndArgs'\nimport { NormalizedClientRequestArgs } from './utils/normalizeClientRequestArgs'\nimport { toIsoResponse } from '../../utils/toIsoResponse'\nimport { getIncomingMessageBody } from './utils/getIncomingMessageBody'\nimport { bodyBufferToString } from './utils/bodyBufferToString'\nimport {\n  ClientRequestWriteArgs,\n  normalizeClientRequestWriteArgs,\n} from './utils/normalizeClientRequestWriteArgs'\nimport { cloneIncomingMessage } from './utils/cloneIncomingMessage'\nimport { IsomorphicRequest } from '../../IsomorphicRequest'\nimport { InteractiveIsomorphicRequest } from '../../InteractiveIsomorphicRequest'\nimport { getArrayBuffer } from '../../utils/bufferUtils'\n\nexport type Protocol = 'http' | 'https'\n\nexport interface NodeClientOptions {\n  emitter: ClientRequestEmitter\n  log: Debugger\n}\n\nexport class NodeClientRequest extends ClientRequest {\n  /**\n   * The list of internal Node.js errors to suppress while\n   * using the \"mock\" response source.\n   */\n  static suppressErrorCodes = [\n    'ENOTFOUND',\n    'ECONNREFUSED',\n    'ECONNRESET',\n    'EAI_AGAIN',\n  ]\n\n  private url: URL\n  private options: RequestOptions\n  private response: IncomingMessage\n  private emitter: ClientRequestEmitter\n  private log: Debugger\n  private chunks: Array<{\n    chunk?: string | Buffer\n    encoding?: BufferEncoding\n  }> = []\n  private responseSource: 'mock' | 'bypass' = 'mock'\n  private capturedError?: NodeJS.ErrnoException\n\n  public requestBody: Buffer[] = []\n\n  constructor(\n    [url, requestOptions, callback]: NormalizedClientRequestArgs,\n    options: NodeClientOptions\n  ) {\n    super(requestOptions, callback)\n\n    this.log = options.log.extend(\n      `request ${requestOptions.method} ${url.href}`\n    )\n\n    this.log('constructing ClientRequest using options:', {\n      url,\n      requestOptions,\n      callback,\n    })\n\n    this.url = url\n    this.options = requestOptions\n    this.emitter = options.emitter\n\n    // Construct a mocked response message.\n    this.response = new IncomingMessage(this.socket!)\n  }\n\n  write(...args: ClientRequestWriteArgs): boolean {\n    const [chunk, encoding, callback] = normalizeClientRequestWriteArgs(args)\n    this.log('write:', { chunk, encoding, callback })\n    this.chunks.push({ chunk, encoding })\n    this.requestBody = concatChunkToBuffer(chunk, this.requestBody)\n    this.log('chunk successfully stored!', this.requestBody)\n\n    /**\n     * Prevent invoking the callback if the written chunk is empty.\n     * @see https://nodejs.org/api/http.html#requestwritechunk-encoding-callback\n     */\n    if (!chunk || chunk.length === 0) {\n      this.log('written chunk is empty, skipping callback...')\n    } else {\n      callback?.()\n    }\n\n    // Do not write the request body chunks to prevent\n    // the Socket from sending data to a potentially existing\n    // server when there is a mocked response defined.\n    return true\n  }\n\n  end(...args: any): this {\n    this.log('end', args)\n\n    const [chunk, encoding, callback] = normalizeClientRequestEndArgs(...args)\n    this.log('normalized arguments:', { chunk, encoding, callback })\n\n    const requestBody = this.getRequestBody(chunk)\n    const isomorphicRequest = this.toIsomorphicRequest(requestBody)\n    const interactiveIsomorphicRequest = new InteractiveIsomorphicRequest(\n      isomorphicRequest\n    )\n\n    // Notify the interceptor about the request.\n    // This will call any \"request\" listeners the users have.\n    this.log(\n      'emitting the \"request\" event for %d listener(s)...',\n      this.emitter.listenerCount('request')\n    )\n    this.emitter.emit('request', interactiveIsomorphicRequest)\n\n    // Execute the resolver Promise like a side-effect.\n    // Node.js 16 forces \"ClientRequest.end\" to be synchronous and return \"this\".\n    until(async () => {\n      await this.emitter.untilIdle('request', ({ args: [request] }) => {\n        /**\n         * @note Await only those listeners that are relevant to this request.\n         * This prevents extraneous parallel request from blocking the resolution\n         * of another, unrelated request. For example, during response patching,\n         * when request resolution is nested.\n         */\n        return request.id === interactiveIsomorphicRequest.id\n      })\n\n      const [mockedResponse] =\n        await interactiveIsomorphicRequest.respondWith.invoked()\n      this.log('event.respondWith called with:', mockedResponse)\n\n      return mockedResponse\n    }).then(([resolverException, mockedResponse]) => {\n      this.log('the listeners promise awaited!')\n\n      // Halt the request whenever the resolver throws an exception.\n      if (resolverException) {\n        this.log(\n          'encountered resolver exception, aborting request...',\n          resolverException\n        )\n        this.emit('error', resolverException)\n        this.terminate()\n\n        return this\n      }\n\n      if (mockedResponse) {\n        this.log('received mocked response:', mockedResponse)\n        this.responseSource = 'mock'\n\n        const isomorphicResponse = toIsoResponse(mockedResponse)\n        this.respondWith(mockedResponse)\n        this.log(\n          isomorphicResponse.status,\n          isomorphicResponse.statusText,\n          isomorphicResponse.body,\n          '(MOCKED)'\n        )\n\n        callback?.()\n\n        this.log('emitting the custom \"response\" event...')\n\n        this.emitter.emit('response', isomorphicRequest, isomorphicResponse)\n\n        return this\n      }\n\n      this.log('no mocked response received!')\n\n      // Set the response source to \"bypass\".\n      // Any errors emitted past this point are not suppressed.\n      this.responseSource = 'bypass'\n\n      // Propagate previously captured errors.\n      // For example, a ECONNREFUSED error when connecting to a non-existing host.\n      if (this.capturedError) {\n        this.emit('error', this.capturedError)\n        return this\n      }\n\n      // Write the request body chunks in the order of \".write()\" calls.\n      // Note that no request body has been written prior to this point\n      // in order to prevent the Socket to communicate with a potentially\n      // existing server.\n      this.log('writing request chunks...', this.chunks)\n\n      for (const { chunk, encoding } of this.chunks) {\n        if (encoding) {\n          super.write(chunk, encoding)\n        } else {\n          super.write(chunk)\n        }\n      }\n\n      this.once('error', (error) => {\n        this.log('original request error:', error)\n      })\n\n      this.once('abort', () => {\n        this.log('original request aborted!')\n      })\n\n      this.once('response-internal', async (response: IncomingMessage) => {\n        const responseBody = await getIncomingMessageBody(response)\n        this.log(response.statusCode, response.statusMessage, responseBody)\n        this.log('original response headers:', response.headers)\n\n        this.log('emitting the custom \"response\" event...')\n        this.emitter.emit('response', isomorphicRequest, {\n          status: response.statusCode || 200,\n          statusText: response.statusMessage || 'OK',\n          headers: objectToHeaders(response.headers),\n          body: responseBody,\n        })\n      })\n\n      this.log('performing original request...')\n\n      return super.end(\n        ...[\n          chunk,\n          encoding as any,\n          () => {\n            this.log('original request end!')\n            callback?.()\n          },\n        ].filter(Boolean)\n      )\n    })\n\n    return this\n  }\n\n  emit(event: string, ...data: any[]) {\n    this.log('event:%s', event)\n\n    if (event === 'response') {\n      this.log('found \"response\" event, cloning the response...')\n\n      try {\n        /**\n         * Clone the response object when emitting the \"response\" event.\n         * This prevents the response body stream from locking\n         * and allows reading it twice:\n         * 1. Internal \"response\" event from the observer.\n         * 2. Any external response body listeners.\n         * @see https://github.com/mswjs/interceptors/issues/161\n         */\n        const response = data[0] as IncomingMessage\n        const firstClone = cloneIncomingMessage(response)\n        const secondClone = cloneIncomingMessage(response)\n\n        this.emit('response-internal', secondClone)\n\n        this.log('response successfully cloned, emitting \"response\" event...')\n        return super.emit(event, firstClone, ...data.slice(1))\n      } catch (error) {\n        this.log('error when cloning response:', error)\n        return super.emit(event, ...data)\n      }\n    }\n\n    if (event === 'error') {\n      const error = data[0] as NodeJS.ErrnoException\n      const errorCode = error.code || ''\n\n      this.log('error:\\n', error)\n\n      // Suppress certain errors while using the \"mock\" source.\n      // For example, no need to destroy this request if it connects\n      // to a non-existing hostname but has a mocked response.\n      if (\n        this.responseSource === 'mock' &&\n        NodeClientRequest.suppressErrorCodes.includes(errorCode)\n      ) {\n        // Capture the first emitted error in order to replay\n        // it later if this request won't have any mocked response.\n        if (!this.capturedError) {\n          this.capturedError = error\n          this.log('captured the first error:', this.capturedError)\n        }\n        return false\n      }\n    }\n\n    return super.emit(event, ...data)\n  }\n\n  private respondWith(mockedResponse: MockedResponse): void {\n    this.log('responding with a mocked response...', mockedResponse)\n\n    const { status, statusText, headers, body } = mockedResponse\n    this.response.statusCode = status\n    this.response.statusMessage = statusText\n\n    if (headers) {\n      this.response.headers = {}\n\n      for (const [headerName, headerValue] of Object.entries(headers)) {\n        this.response.rawHeaders.push(\n          headerName,\n          ...(Array.isArray(headerValue) ? headerValue : [headerValue])\n        )\n\n        const insensitiveHeaderName = headerName.toLowerCase()\n        const prevHeaders = this.response.headers[insensitiveHeaderName]\n        this.response.headers[insensitiveHeaderName] = prevHeaders\n          ? Array.prototype.concat([], prevHeaders, headerValue)\n          : headerValue\n      }\n    }\n    this.log('mocked response headers ready:', headers)\n\n    if (body) {\n      this.response.push(Buffer.from(body))\n    }\n\n    // Push \"null\" to indicate that the response body is complete\n    // and shouldn't be written to anymore.\n    this.response.push(null)\n    this.response.complete = true\n\n    /**\n     * Set the internal \"res\" property to the mocked \"OutgoingMessage\"\n     * to make the \"ClientRequest\" instance think there's data received\n     * from the socket.\n     * @see https://github.com/nodejs/node/blob/9c405f2591f5833d0247ed0fafdcd68c5b14ce7a/lib/_http_client.js#L501\n     */\n    // @ts-ignore\n    this.res = this.response\n\n    this.finished = true\n    Object.defineProperty(this, 'writableEnded', {\n      value: true,\n    })\n\n    this.emit('finish')\n    this.emit('response', this.response)\n\n    this.terminate()\n  }\n\n  /**\n   * Terminates a pending request.\n   */\n  private terminate(): void {\n    // @ts-ignore\n    this.agent.destroy()\n  }\n\n  private getRequestBody(chunk: ClientRequestEndChunk | null): ArrayBuffer {\n    const writtenRequestBody = bodyBufferToString(\n      Buffer.concat(this.requestBody)\n    )\n    this.log('written request body:', writtenRequestBody)\n\n    // Write the last request body chunk to the internal request body buffer.\n    if (chunk) {\n      this.requestBody = concatChunkToBuffer(chunk, this.requestBody)\n    }\n\n    const resolvedRequestBody = Buffer.concat(this.requestBody)\n    this.log('resolved request body:', resolvedRequestBody)\n\n    return getArrayBuffer(resolvedRequestBody)\n  }\n\n  private toIsomorphicRequest(body: ArrayBuffer): IsomorphicRequest {\n    this.log('creating isomorphic request object...')\n\n    const outgoingHeaders = this.getHeaders()\n    this.log('request outgoing headers:', outgoingHeaders)\n\n    const headers = new Headers()\n    for (const [headerName, headerValue] of Object.entries(outgoingHeaders)) {\n      if (!headerValue) {\n        continue\n      }\n\n      headers.set(headerName.toLowerCase(), headerValue.toString())\n    }\n\n    const isomorphicRequest = new IsomorphicRequest(this.url, {\n      body,\n      method: this.options.method || 'GET',\n      credentials: 'same-origin',\n      headers,\n    })\n\n    this.log('successfully created isomorphic request!', isomorphicRequest)\n    return isomorphicRequest\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}