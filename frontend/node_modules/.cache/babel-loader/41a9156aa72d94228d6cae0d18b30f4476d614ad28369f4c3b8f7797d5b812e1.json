{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getIncomingMessageBody = void 0;\nvar debug_1 = require(\"debug\");\nvar stream_1 = require(\"stream\");\nvar zlib = __importStar(require(\"zlib\"));\nvar log = debug_1.debug('http getIncomingMessageBody');\nfunction getIncomingMessageBody(response) {\n  return new Promise(function (resolve, reject) {\n    log('cloning the original response...');\n    // Pipe the original response to support non-clone\n    // \"response\" input. No need to clone the response,\n    // as we always have access to the full \"response\" input,\n    // either a clone or an original one (in tests).\n    var responseClone = response.pipe(new stream_1.PassThrough());\n    var stream = response.headers['content-encoding'] === 'gzip' ? responseClone.pipe(zlib.createGunzip()) : responseClone;\n    var encoding = response.readableEncoding || 'utf8';\n    stream.setEncoding(encoding);\n    log('using encoding:', encoding);\n    var body = '';\n    stream.on('data', function (responseBody) {\n      log('response body read:', responseBody);\n      body += responseBody;\n    });\n    stream.once('end', function () {\n      log('response body end');\n      resolve(body);\n    });\n    stream.once('error', function (error) {\n      log('error while reading response body:', error);\n      reject(error);\n    });\n  });\n}\nexports.getIncomingMessageBody = getIncomingMessageBody;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AAEA,IAAMA,GAAG,GAAGC,aAAK,CAAC,6BAA6B,CAAC;AAEhD,SAAgBC,sBAAsB,CACpCC,QAAyB;EAEzB,OAAO,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM;IACjCN,GAAG,CAAC,kCAAkC,CAAC;IAEvC;IACA;IACA;IACA;IACA,IAAMO,aAAa,GAAGJ,QAAQ,CAACK,IAAI,CAAC,IAAIC,oBAAW,EAAE,CAAC;IACtD,IAAMC,MAAM,GACVP,QAAQ,CAACQ,OAAO,CAAC,kBAAkB,CAAC,KAAK,MAAM,GAC3CJ,aAAa,CAACC,IAAI,CAACI,IAAI,CAACC,YAAY,EAAE,CAAC,GACvCN,aAAa;IAEnB,IAAMO,QAAQ,GAAGX,QAAQ,CAACY,gBAAgB,IAAI,MAAM;IACpDL,MAAM,CAACM,WAAW,CAACF,QAAQ,CAAC;IAC5Bd,GAAG,CAAC,iBAAiB,EAAEc,QAAQ,CAAC;IAEhC,IAAIG,IAAI,GAAG,EAAE;IAEbP,MAAM,CAACQ,EAAE,CAAC,MAAM,EAAE,UAACC,YAAY;MAC7BnB,GAAG,CAAC,qBAAqB,EAAEmB,YAAY,CAAC;MACxCF,IAAI,IAAIE,YAAY;IACtB,CAAC,CAAC;IAEFT,MAAM,CAACU,IAAI,CAAC,KAAK,EAAE;MACjBpB,GAAG,CAAC,mBAAmB,CAAC;MACxBK,OAAO,CAACY,IAAI,CAAC;IACf,CAAC,CAAC;IAEFP,MAAM,CAACU,IAAI,CAAC,OAAO,EAAE,UAACC,KAAK;MACzBrB,GAAG,CAAC,oCAAoC,EAAEqB,KAAK,CAAC;MAChDf,MAAM,CAACe,KAAK,CAAC;IACf,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AArCAC","names":["log","debug_1","getIncomingMessageBody","response","Promise","resolve","reject","responseClone","pipe","stream_1","stream","headers","zlib","createGunzip","encoding","readableEncoding","setEncoding","body","on","responseBody","once","error","exports"],"sources":["C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\ClientRequest\\utils\\getIncomingMessageBody.ts"],"sourcesContent":["import { debug } from 'debug'\nimport { IncomingMessage } from 'http'\nimport { PassThrough } from 'stream'\nimport * as zlib from 'zlib'\n\nconst log = debug('http getIncomingMessageBody')\n\nexport function getIncomingMessageBody(\n  response: IncomingMessage\n): Promise<string> {\n  return new Promise((resolve, reject) => {\n    log('cloning the original response...')\n\n    // Pipe the original response to support non-clone\n    // \"response\" input. No need to clone the response,\n    // as we always have access to the full \"response\" input,\n    // either a clone or an original one (in tests).\n    const responseClone = response.pipe(new PassThrough())\n    const stream =\n      response.headers['content-encoding'] === 'gzip'\n        ? responseClone.pipe(zlib.createGunzip())\n        : responseClone\n\n    const encoding = response.readableEncoding || 'utf8'\n    stream.setEncoding(encoding)\n    log('using encoding:', encoding)\n\n    let body = ''\n\n    stream.on('data', (responseBody) => {\n      log('response body read:', responseBody)\n      body += responseBody\n    })\n\n    stream.once('end', () => {\n      log('response body end')\n      resolve(body)\n    })\n\n    stream.once('error', (error) => {\n      log('error while reading response body:', error)\n      reject(error)\n    })\n  })\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}