{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __require = /* @__PURE__ */(x => typeof require !== \"undefined\" ? require : typeof Proxy !== \"undefined\" ? new Proxy(x, {\n  get: (a, b) => (typeof require !== \"undefined\" ? require : a)[b]\n}) : x)(function (x) {\n  if (typeof require !== \"undefined\") return require.apply(this, arguments);\n  throw new Error('Dynamic require of \"' + x + '\" is not supported');\n});\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\n\n// config/polyfills-node.ts\nimport { setTimeout as nodeSetTimeout } from \"timers\";\nvar setTimeout = nodeSetTimeout;\n\n// src/node/SetupServerApi.ts\nimport chalk from \"chalk\";\nimport { invariant as invariant3 } from \"outvariant\";\nimport { BatchInterceptor, InterceptorReadyState } from \"@mswjs/interceptors\";\n\n// src/SetupApi.ts\nimport { invariant } from \"outvariant\";\nimport { StrictEventEmitter } from \"strict-event-emitter\";\n\n// src/utils/internal/devUtils.ts\nimport { format } from \"outvariant\";\nvar LIBRARY_PREFIX = \"[MSW]\";\nfunction formatMessage(message) {\n  for (var _len = arguments.length, positionals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    positionals[_key - 1] = arguments[_key];\n  }\n  const interpolatedMessage = format(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\nfunction warn(message) {\n  for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    positionals[_key2 - 1] = arguments[_key2];\n  }\n  console.warn(formatMessage(message, ...positionals));\n}\nfunction error(message) {\n  for (var _len3 = arguments.length, positionals = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    positionals[_key3 - 1] = arguments[_key3];\n  }\n  console.error(formatMessage(message, ...positionals));\n}\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n};\n\n// src/utils/internal/pipeEvents.ts\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n  if (rawEmit._isPiped) {\n    return;\n  }\n  source.emit = function (event) {\n    for (var _len4 = arguments.length, data2 = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      data2[_key4 - 1] = arguments[_key4];\n    }\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n  source.emit._isPiped = true;\n}\n\n// src/utils/internal/toReadonlyArray.ts\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n}\n\n// src/SetupApi.ts\nvar SetupApi = class {\n  constructor() {\n    for (var _len5 = arguments.length, initialHandlers = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      initialHandlers[_key5] = arguments[_key5];\n    }\n    this.validateHandlers(...initialHandlers);\n    this.initialHandlers = toReadonlyArray(initialHandlers);\n    this.currentHandlers = [...initialHandlers];\n    this.emitter = new StrictEventEmitter();\n    this.publicEmitter = new StrictEventEmitter();\n    pipeEvents(this.emitter, this.publicEmitter);\n    this.events = this.createLifeCycleEvents();\n  }\n  validateHandlers() {\n    for (var _len6 = arguments.length, handlers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      handlers[_key6] = arguments[_key6];\n    }\n    for (const handler of handlers) {\n      invariant(!Array.isArray(handler), devUtils.formatMessage('Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.'), this.constructor.name);\n    }\n  }\n  dispose() {\n    this.emitter.removeAllListeners();\n    this.publicEmitter.removeAllListeners();\n  }\n  use() {\n    this.currentHandlers.unshift(...arguments);\n  }\n  restoreHandlers() {\n    this.currentHandlers.forEach(handler => {\n      handler.markAsSkipped(false);\n    });\n  }\n  resetHandlers() {\n    for (var _len7 = arguments.length, nextHandlers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      nextHandlers[_key7] = arguments[_key7];\n    }\n    this.currentHandlers = nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers];\n  }\n  listHandlers() {\n    return toReadonlyArray(this.currentHandlers);\n  }\n  createLifeCycleEvents() {\n    var _this = this;\n    return {\n      on: function () {\n        return _this.publicEmitter.on(...arguments);\n      },\n      removeListener: function () {\n        return _this.publicEmitter.removeListener(...arguments);\n      },\n      removeAllListeners: function () {\n        return _this.publicEmitter.removeAllListeners(...arguments);\n      }\n    };\n  }\n};\n\n// src/utils/internal/isObject.ts\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n}\n\n// src/utils/internal/mergeRight.ts\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, _ref) => {\n    let [key, rightValue] = _ref;\n    const leftValue = result[key];\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n}\n\n// src/utils/request/MockedRequest.ts\nimport * as cookieUtils2 from \"cookie\";\nimport { store } from \"@mswjs/cookies\";\nimport { IsomorphicRequest } from \"@mswjs/interceptors\";\nimport { decodeBuffer } from \"@mswjs/interceptors/lib/utils/bufferUtils.js\";\nimport { Headers } from \"headers-polyfill\";\n\n// src/utils/request/getRequestCookies.ts\nimport * as cookieUtils from \"cookie\";\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie);\n}\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n  switch (request.credentials) {\n    case \"same-origin\":\n      {\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n    case \"include\":\n      {\n        return getAllCookies();\n      }\n    default:\n      {\n        return {};\n      }\n  }\n}\n\n// src/utils/internal/jsonParse.ts\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/internal/parseMultipartData.ts\nimport { stringToHeaders } from \"headers-polyfill\";\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n  const headers = stringToHeaders(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest] = chunk.trim().split(\"=\");\n    acc[name2] = rest.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n  if (!contentType) {\n    return void 0;\n  }\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n  if (!boundary) {\n    return void 0;\n  }\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n  if (!fields.length) {\n    return void 0;\n  }\n  const parsedBody = {};\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n}\n\n// src/utils/request/parseBody.ts\nfunction parseBody(body2, headers) {\n  var _a;\n  if (!body2) {\n    return body2;\n  }\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n  const hasJsonContent = contentType.includes(\"json\");\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n  return body2;\n}\n\n// src/utils/internal/isStringEqual.ts\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n}\n\n// src/utils/request/MockedRequest.ts\nvar MockedRequest = class extends IsomorphicRequest {\n  constructor(url) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(url, init);\n    if (init.id) {\n      this.id = init.id;\n    }\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n  get body() {\n    const text2 = decodeBuffer(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n    return body2;\n  }\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n  getCookies() {\n    var _a;\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils2.parse(requestCookiesString) : {};\n    store.hydrate();\n    const cookiesFromStore = Array.from((_a = store.get(__spreadProps(__spreadValues({}, this), {\n      url: this.url.href\n    }))) == null ? void 0 : _a.entries()).reduce((cookies, _ref2) => {\n      let [name, {\n        value\n      }] = _ref2;\n      return Object.assign(cookies, {\n        [name.trim()]: value\n      });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n    const forwardedCookies = __spreadValues(__spreadValues({}, cookiesFromDocument), cookiesFromStore);\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n    return __spreadValues(__spreadValues({}, forwardedCookies), ownCookies);\n  }\n};\n\n// src/utils/handleRequest.ts\nimport { until } from \"@open-draft/until\";\n\n// src/utils/getResponse.ts\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n    const result2 = await handler.run(request, resolutionContext);\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n    return result2;\n  }, Promise.resolve(null));\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n};\n\n// src/utils/request/onUnhandledRequest.ts\nimport getStringMatchScore from \"js-levenshtein\";\n\n// src/utils/internal/parseGraphQLRequest.ts\nimport { parse as parse3 } from \"graphql\";\n\n// src/utils/request/getPublicUrlFromRequest.ts\nvar getPublicUrlFromRequest = request => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, `${request.url.protocol}//${request.url.host}`).href;\n};\n\n// src/utils/internal/parseGraphQLRequest.ts\nfunction parseDocumentNode(node) {\n  var _a;\n  const operationDef = node.definitions.find(def => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\nfunction parseQuery(query) {\n  try {\n    const ast = parse3(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n        target = target[path];\n      }\n      target[lastPath] = files[key];\n    }\n  }\n  return operations.variables;\n}\nfunction getGraphQLInput(request) {\n  var _a, _b;\n  switch (request.method) {\n    case \"GET\":\n      {\n        const query = request.url.searchParams.get(\"query\");\n        const variables = request.url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n    case \"POST\":\n      {\n        if ((_a = request.body) == null ? void 0 : _a.query) {\n          const {\n            query,\n            variables\n          } = request.body;\n          return {\n            query,\n            variables\n          };\n        }\n        if ((_b = request.body) == null ? void 0 : _b.operations) {\n          const _c = request.body,\n            {\n              operations,\n              map\n            } = _c,\n            files = __objRest(_c, [\"operations\", \"map\"]);\n          const parsedOperations = jsonParse(operations) || {};\n          if (!parsedOperations.query) {\n            return null;\n          }\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n      }\n    default:\n      return null;\n  }\n}\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n  if (!input || !input.query) {\n    return void 0;\n  }\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = parseQuery(query);\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n}\n\n// node_modules/statuses/codes.json\nvar _00 = \"Continue\";\nvar _01 = \"Switching Protocols\";\nvar _02 = \"Processing\";\nvar _03 = \"Early Hints\";\nvar _002 = \"OK\";\nvar _012 = \"Created\";\nvar _022 = \"Accepted\";\nvar _032 = \"Non-Authoritative Information\";\nvar _04 = \"No Content\";\nvar _05 = \"Reset Content\";\nvar _06 = \"Partial Content\";\nvar _07 = \"Multi-Status\";\nvar _08 = \"Already Reported\";\nvar _26 = \"IM Used\";\nvar _003 = \"Multiple Choices\";\nvar _013 = \"Moved Permanently\";\nvar _023 = \"Found\";\nvar _033 = \"See Other\";\nvar _042 = \"Not Modified\";\nvar _052 = \"Use Proxy\";\nvar _072 = \"Temporary Redirect\";\nvar _082 = \"Permanent Redirect\";\nvar _004 = \"Bad Request\";\nvar _014 = \"Unauthorized\";\nvar _024 = \"Payment Required\";\nvar _034 = \"Forbidden\";\nvar _043 = \"Not Found\";\nvar _053 = \"Method Not Allowed\";\nvar _062 = \"Not Acceptable\";\nvar _073 = \"Proxy Authentication Required\";\nvar _083 = \"Request Timeout\";\nvar _09 = \"Conflict\";\nvar _10 = \"Gone\";\nvar _11 = \"Length Required\";\nvar _12 = \"Precondition Failed\";\nvar _13 = \"Payload Too Large\";\nvar _14 = \"URI Too Long\";\nvar _15 = \"Unsupported Media Type\";\nvar _16 = \"Range Not Satisfiable\";\nvar _17 = \"Expectation Failed\";\nvar _18 = \"I'm a Teapot\";\nvar _21 = \"Misdirected Request\";\nvar _22 = \"Unprocessable Entity\";\nvar _23 = \"Locked\";\nvar _24 = \"Failed Dependency\";\nvar _25 = \"Too Early\";\nvar _262 = \"Upgrade Required\";\nvar _28 = \"Precondition Required\";\nvar _29 = \"Too Many Requests\";\nvar _31 = \"Request Header Fields Too Large\";\nvar _51 = \"Unavailable For Legal Reasons\";\nvar _005 = \"Internal Server Error\";\nvar _015 = \"Not Implemented\";\nvar _025 = \"Bad Gateway\";\nvar _035 = \"Service Unavailable\";\nvar _044 = \"Gateway Timeout\";\nvar _054 = \"HTTP Version Not Supported\";\nvar _063 = \"Variant Also Negotiates\";\nvar _074 = \"Insufficient Storage\";\nvar _084 = \"Loop Detected\";\nvar _092 = \"Bandwidth Limit Exceeded\";\nvar _102 = \"Not Extended\";\nvar _112 = \"Network Authentication Required\";\nvar codes_default = {\n  \"100\": _00,\n  \"101\": _01,\n  \"102\": _02,\n  \"103\": _03,\n  \"200\": _002,\n  \"201\": _012,\n  \"202\": _022,\n  \"203\": _032,\n  \"204\": _04,\n  \"205\": _05,\n  \"206\": _06,\n  \"207\": _07,\n  \"208\": _08,\n  \"226\": _26,\n  \"300\": _003,\n  \"301\": _013,\n  \"302\": _023,\n  \"303\": _033,\n  \"304\": _042,\n  \"305\": _052,\n  \"307\": _072,\n  \"308\": _082,\n  \"400\": _004,\n  \"401\": _014,\n  \"402\": _024,\n  \"403\": _034,\n  \"404\": _043,\n  \"405\": _053,\n  \"406\": _062,\n  \"407\": _073,\n  \"408\": _083,\n  \"409\": _09,\n  \"410\": _10,\n  \"411\": _11,\n  \"412\": _12,\n  \"413\": _13,\n  \"414\": _14,\n  \"415\": _15,\n  \"416\": _16,\n  \"417\": _17,\n  \"418\": _18,\n  \"421\": _21,\n  \"422\": _22,\n  \"423\": _23,\n  \"424\": _24,\n  \"425\": _25,\n  \"426\": _262,\n  \"428\": _28,\n  \"429\": _29,\n  \"431\": _31,\n  \"451\": _51,\n  \"500\": _005,\n  \"501\": _015,\n  \"502\": _025,\n  \"503\": _035,\n  \"504\": _044,\n  \"505\": _054,\n  \"506\": _063,\n  \"507\": _074,\n  \"508\": _084,\n  \"509\": _092,\n  \"510\": _102,\n  \"511\": _112\n};\n\n// src/context/status.ts\nvar status = (statusCode, statusText) => {\n  return res => {\n    res.status = statusCode;\n    res.statusText = statusText || codes_default[String(statusCode)];\n    return res;\n  };\n};\n\n// src/context/set.ts\nimport { objectToHeaders } from \"headers-polyfill\";\nfunction set() {\n  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    args[_key8] = arguments[_key8];\n  }\n  return res => {\n    const [name, value] = args;\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = objectToHeaders(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n    return res;\n  };\n}\n\n// src/context/cookie.ts\nimport * as cookieUtils3 from \"cookie\";\nvar cookie = (name, value, options) => {\n  return res => {\n    const serializedCookie = cookieUtils3.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n    return res;\n  };\n};\n\n// src/context/body.ts\nvar body = value => {\n  return res => {\n    res.body = value;\n    return res;\n  };\n};\n\n// src/context/json.ts\nvar json = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n};\n\n// src/context/data.ts\nvar data = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      data: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/extensions.ts\nvar extensions = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      extensions: payload\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/delay.ts\nimport { isNodeProcess } from \"is-node-process\";\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\nvar getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n};\nvar delay = durationOrMode => {\n  return res => {\n    let delayTime;\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n        case \"real\":\n          {\n            delayTime = getRandomServerResponseTime();\n            break;\n          }\n        default:\n          {\n            throw new Error(`Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`);\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(`Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`);\n      }\n      delayTime = durationOrMode;\n    }\n    res.delay = delayTime;\n    return res;\n  };\n};\n\n// src/context/errors.ts\nvar errors = errorsList => {\n  return res => {\n    if (errorsList == null) {\n      return res;\n    }\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      errors: errorsList\n    });\n    return json(nextBody)(res);\n  };\n};\n\n// src/context/fetch.ts\nimport { isNodeProcess as isNodeProcess2 } from \"is-node-process\";\nimport { Headers as Headers2 } from \"headers-polyfill\";\nvar useFetch = isNodeProcess2() ? (input, init) => Promise.resolve().then(() => __toESM(__require(\"node-fetch\"))).then(_ref3 => {\n  let {\n    default: nodeFetch\n  } = _ref3;\n  return nodeFetch(input, init);\n}) : window.fetch;\nvar augmentRequestInit = requestInit => {\n  const headers = new Headers2(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return __spreadProps(__spreadValues({}, requestInit), {\n    headers: headers.all()\n  });\n};\nvar createFetchRequestParameters = input => {\n  const {\n    body: body2,\n    method\n  } = input;\n  const requestParameters = __spreadProps(__spreadValues({}, input), {\n    body: void 0\n  });\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n  return requestParameters;\n};\nvar fetch = function (input) {\n  let requestInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n};\n\n// src/context/text.ts\nvar text = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/context/xml.ts\nvar xml = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n};\n\n// src/utils/logging/getStatusCodeColor.ts\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\" /* Success */;\n  }\n\n  if (status2 < 400) {\n    return \"#F0BB4B\" /* Warning */;\n  }\n\n  return \"#E95F5D\" /* Danger */;\n}\n\n// src/utils/logging/getTimestamp.ts\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, \"0\")).join(\":\");\n}\n\n// src/utils/logging/prepareRequest.ts\nfunction prepareRequest(request) {\n  return __spreadProps(__spreadValues({}, request), {\n    body: request.body,\n    headers: request.headers.all()\n  });\n}\n\n// src/utils/logging/prepareResponse.ts\nimport { objectToHeaders as objectToHeaders2 } from \"headers-polyfill\";\nfunction prepareResponse(res) {\n  const responseHeaders = objectToHeaders2(res.headers);\n  return __spreadProps(__spreadValues({}, res), {\n    body: parseBody(res.body, responseHeaders)\n  });\n}\n\n// src/utils/matching/matchRequestUrl.ts\nimport { match } from \"path-to-regexp\";\nimport { getCleanUrl } from \"@mswjs/interceptors/lib/utils/getCleanUrl.js\";\n\n// src/utils/url/cleanUrl.ts\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n}\n\n// src/utils/url/isAbsoluteUrl.ts\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n}\n\n// src/utils/url/getAbsoluteUrl.ts\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n}\n\n// src/utils/matching/normalizePath.ts\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n}\n\n// src/utils/matching/matchRequestUrl.ts\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = \"(.*)\";\n    if (!parameterName) {\n      return expression;\n    }\n    return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = getCleanUrl(url);\n  const result = match(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n}\n\n// src/handlers/RequestHandler.ts\nimport { Headers as Headers4 } from \"headers-polyfill\";\n\n// src/response.ts\nimport { Headers as Headers3 } from \"headers-polyfill\";\n\n// src/utils/internal/compose.ts\nfunction compose() {\n  for (var _len9 = arguments.length, fns = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    fns[_key9] = arguments[_key9];\n  }\n  return function () {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, arguments.length <= 0 ? undefined : arguments[0]);\n  };\n}\n\n// src/utils/NetworkError.ts\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n};\n\n// src/response.ts\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\nfunction createResponseComposition(responseOverrides) {\n  let defaultTransformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultResponseTransformers;\n  return async function () {\n    const initialResponse = Object.assign({}, defaultResponse, {\n      headers: new Headers3({\n        \"x-powered-by\": \"msw\"\n      })\n    }, responseOverrides);\n    for (var _len10 = arguments.length, transformers = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      transformers[_key10] = arguments[_key10];\n    }\n    const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n});\n\n// src/utils/internal/getCallFrame.ts\nvar SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n  if (!stack) {\n    return;\n  }\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find(frame => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n  if (!declarationFrame) {\n    return;\n  }\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n}\n\n// src/utils/internal/isIterable.ts\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n  return typeof fn[Symbol.iterator] == \"function\";\n}\n\n// src/handlers/RequestHandler.ts\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = __spreadProps(__spreadValues({}, options.info), {\n      callFrame\n    });\n  }\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n  test(request, resolutionContext) {\n    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n  }\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n  markAsSkipped() {\n    let shouldSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.shouldSkip = shouldSkip;\n  }\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n    if (!shouldIntercept) {\n      return null;\n    }\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(publicRequest, response, this.ctx);\n    return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);\n  }\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx));\n      if (isIterable(result)) {\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n      return result;\n    };\n  }\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n};\n\n// src/handlers/RestHandler.ts\nvar restContext = __spreadProps(__spreadValues({}, defaultContext), {\n  cookie,\n  body,\n  text,\n  json,\n  xml\n});\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    this.params = params;\n    this.id = request.id;\n  }\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n  checkRedundantQueryParameters() {\n    const {\n      method,\n      path\n    } = this.info;\n    if (path instanceof RegExp) {\n      return;\n    }\n    const url = cleanUrl(path);\n    if (url === path) {\n      return;\n    }\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(`Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`);\n  }\n  parse(request, resolutionContext) {\n    return matchRequestUrl(request.url, this.info.path, resolutionContext == null ? void 0 : resolutionContext.baseUrl);\n  }\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s %s (%c%s%c)\"), getTimestamp(), request.method, publicUrl, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/context/field.ts\nimport { invariant as invariant2 } from \"outvariant\";\nvar field = (fieldName, fieldValue) => {\n  return res => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      [fieldName]: fieldValue\n    });\n    return json(nextBody)(res);\n  };\n};\nfunction validateFieldName(fieldName) {\n  invariant2(fieldName.trim() !== \"\", devUtils.formatMessage(\"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"));\n  invariant2(fieldName !== \"data\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?', fieldName));\n  invariant2(fieldName !== \"errors\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?', fieldName));\n  invariant2(fieldName !== \"extensions\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?', fieldName));\n}\n\n// src/utils/internal/tryCatch.ts\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n}\n\n// src/handlers/GraphQLHandler.ts\nvar graphqlContext = __spreadProps(__spreadValues({}, defaultContext), {\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n});\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables) {\n    super(request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    this.variables = variables;\n  }\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`);\n      }\n      if (!parsedNode.operationName) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);\n      }\n      resolvedOperationName = parsedNode.operationName;\n    }\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n  parse(request) {\n    return tryCatch(() => parseGraphQLRequest(request), error2 => console.error(error2.message));\n  }\n  getPublicRequest(request, parsedResult) {\n    return new GraphQLRequest(request, (parsedResult == null ? void 0 : parsedResult.variables) || {});\n  }\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s (%c%s%c)\"), getTimestamp(), `${requestInfo}`, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n};\n\n// src/utils/request/onUnhandledRequest.ts\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = getStringMatchScore(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = getStringMatchScore(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort((_ref4, _ref5) => {\n    let [leftScore] = _ref4;\n    let [rightScore] = _ref5;\n    return leftScore - rightScore;\n  }).filter(_ref6 => {\n    let [score] = _ref6;\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(_ref7 => {\n    let [, handler] = _ref7;\n    return handler;\n  });\n  return suggestedHandlers;\n}\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\nfunction onUnhandledRequest(request, handlers) {\n  let strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"warn\";\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n      case \"bypass\":\n        break;\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n  applyStrategy(strategy);\n}\n\n// src/utils/request/readResponseCookies.ts\nimport { store as store2 } from \"@mswjs/cookies\";\nfunction readResponseCookies(request, response2) {\n  store2.add(__spreadProps(__spreadValues({}, request), {\n    url: request.url.toString()\n  }), response2);\n  store2.persist();\n}\n\n// src/utils/handleRequest.ts\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n  emitter.emit(\"request:start\", request);\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n  });\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n  const {\n    handler,\n    response: response2\n  } = lookupResult;\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n  if (!response2) {\n    devUtils.warn(`Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`, response2, handler.info.header, handler.info.callFrame);\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n}\n\n// src/node/SetupServerApi.ts\nvar {\n  bold\n} = chalk;\nvar DEFAULT_LISTEN_OPTIONS = {\n  onUnhandledRequest: \"warn\"\n};\nvar SetupServerApi = class extends SetupApi {\n  constructor(interceptors) {\n    for (var _len11 = arguments.length, handlers = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      handlers[_key11 - 1] = arguments[_key11];\n    }\n    super(...handlers);\n    this.interceptor = new BatchInterceptor({\n      name: \"setup-server\",\n      interceptors: interceptors.map(Interceptor2 => new Interceptor2())\n    });\n    this.resolvedOptions = {};\n    this.init();\n  }\n  init() {\n    this.interceptor.on(\"request\", async request => {\n      const mockedRequest = new MockedRequest(request.url, __spreadProps(__spreadValues({}, request), {\n        body: await request.arrayBuffer()\n      }));\n      const response2 = await handleRequest(mockedRequest, this.currentHandlers, this.resolvedOptions, this.emitter, {\n        transformResponse(response3) {\n          return {\n            status: response3.status,\n            statusText: response3.statusText,\n            headers: response3.headers.all(),\n            body: response3.body,\n            delay: response3.delay\n          };\n        }\n      });\n      if (response2) {\n        if (response2.delay) {\n          await new Promise(resolve => {\n            setTimeout(resolve, response2.delay);\n          });\n        }\n        request.respondWith(response2);\n      }\n      return;\n    });\n    this.interceptor.on(\"response\", (request, response2) => {\n      if (!request.id) {\n        return;\n      }\n      if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n        this.emitter.emit(\"response:mocked\", response2, request.id);\n      } else {\n        this.emitter.emit(\"response:bypass\", response2, request.id);\n      }\n    });\n  }\n  listen() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.resolvedOptions = mergeRight(DEFAULT_LISTEN_OPTIONS, options);\n    this.interceptor.apply();\n    invariant3([InterceptorReadyState.APPLYING, InterceptorReadyState.APPLIED].includes(this.interceptor.readyState), devUtils.formatMessage('Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".'), \"https://github.com/mswjs/msw/issues/new/choose\");\n  }\n  printHandlers() {\n    const handlers = this.listHandlers();\n    handlers.forEach(handler => {\n      const {\n        header,\n        callFrame\n      } = handler.info;\n      const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n      console.log(`${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`);\n    });\n  }\n  close() {\n    super.dispose();\n    this.interceptor.dispose();\n  }\n};\n\n// src/node/setupServer.ts\nimport { ClientRequestInterceptor } from \"@mswjs/interceptors/lib/interceptors/ClientRequest/index.js\";\nimport { XMLHttpRequestInterceptor } from \"@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js\";\nvar setupServer = function () {\n  for (var _len12 = arguments.length, handlers = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    handlers[_key12] = arguments[_key12];\n  }\n  return new SetupServerApi([ClientRequestInterceptor, XMLHttpRequestInterceptor], ...handlers);\n};\nexport { setupServer };","map":{"version":3,"mappings":"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","names":["setTimeout","nodeSetTimeout","LIBRARY_PREFIX","message","positionals","interpolatedMessage","format","console","warn","formatMessage","error","devUtils","source","destination","rawEmit","emit","_isPiped","event","data2","call","clone","Object","freeze","constructor","initialHandlers","validateHandlers","toReadonlyArray","currentHandlers","emitter","StrictEventEmitter","publicEmitter","pipeEvents","events","createLifeCycleEvents","handlers","handler","invariant","Array","isArray","name","dispose","removeAllListeners","use","unshift","restoreHandlers","forEach","markAsSkipped","resetHandlers","nextHandlers","length","listHandlers","on","removeListener","value","left","right","entries","reduce","result","key","rightValue","leftValue","concat","isObject","mergeRight","assign","cookieUtils","document","cookie","request","location","credentials","origin","url","getAllCookies","JSON","parse","error2","headersString","headers","stringToHeaders","contentType","get","disposition","Error","directives","split","acc","chunk","name2","rest","trim","join","slice","filename","boundary","filter","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","parsedBody","field2","contentHeaders","contentBody","parseContentHeaders","File","type","contentType2","parsedValue","body2","toLowerCase","hasMultipartContent","parseMultipartData","toString","hasJsonContent","includes","jsonParse","actual","expected","IsomorphicRequest","init","id","cache","integrity","keepalive","mode","priority","redirect","referrer","referrerPolicy","cookies","getCookies","body","text2","decodeBuffer","parseBody","isStringEqual","method","passthrough","status","statusText","Headers","once","requestCookiesString","ownCookies","cookieUtils2","store","hydrate","cookiesFromStore","from","__spreadProps","href","cookiesFromDocument","getRequestCookies","forwardedCookies","__spreadValues","append","getResponse","resolutionContext","relevantHandlers","test","response","executionResult","previousResults","result2","run","shouldSkip","parsedResult","Promise","resolve","publicRequest","parsedRequest","getPublicUrlFromRequest","pathname","URL","protocol","host","node","operationDef","definitions","find","def","kind","operationType","operation","operationName","query","ast","parse3","parseDocumentNode","variables","files","operations","pathArray","dotPath","lastPath","reversedPaths","reverse","paths","target","path","searchParams","_c","parsedOperations","parsedMap","extractMultipartVariables","input","getGraphQLInput","parseQuery","requestPublicUrl","statusCode","res","codes_default","String","args","objectToHeaders","value2","options","serializedCookie","cookieUtils3","json","set","stringify","data","payload","prevBody","nextBody","extensions","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRandomServerResponseTime","isNodeProcess","Math","floor","random","delay","durationOrMode","delayTime","errors","errorsList","useFetch","isNodeProcess2","then","default","nodeFetch","window","fetch","augmentRequestInit","requestInit","Headers2","all","createFetchRequestParameters","requestParameters","derivedRequestInit","text","xml","status2","now","Date","getHours","getMinutes","getSeconds","padStart","responseHeaders","objectToHeaders2","REDUNDANT_CHARACTERS_EXP","baseUrl","isAbsoluteUrl","baseURI","decodeURI","encodeURI","maybeAbsoluteUrl","getAbsoluteUrl","cleanUrl","_","parameterName","wildcard","expression","normalizedPath","normalizePath","cleanPath","coercePath","cleanUrl2","getCleanUrl","match","decode","decodeURIComponent","params","matches","fns","reduceRight","leftFn","rightFn","defaultResponse","defaultResponseTransformers","responseOverrides","defaultTransformers","initialResponse","Headers3","transformers","resolvedTransformers","Boolean","resolvedResponse","compose","createResponseComposition","networkError","NetworkError","SOURCE_FRAME","BUILD_FRAME","stack","frames","declarationFrame","frame","declarationPath","fn","Symbol","iterator","defaultContext","ctx","resolver","callFrame","getCallFrame","info","_request","_resolutionContext","predicate","getPublicRequest","_parsedResult","shouldIntercept","executeResolver","wrapResolver","mockedResponse","createExecutionResult","req","resolverGenerator","isIterable","done","next","nextResponse","resolverGeneratorResult","response2","restContext","MockedRequest","RequestHandler","header","checkRedundantQueryParameters","getSearchParams","queryParams","paramName","push","matchRequestUrl","RestRequest","matchesMethod","log","publicUrl","loggedRequest","prepareRequest","loggedResponse","prepareResponse","statusColor","getStatusCodeColor","groupCollapsed","getTimestamp","groupEnd","field","fieldName","fieldValue","validateFieldName","invariant2","onException","graphqlContext","endpoint","resolvedOperationName","isDocumentNode","parsedNode","tryCatch","parseGraphQLRequest","GraphQLRequest","hasMatchingUrl","hasMatchingOperationType","hasMatchingOperationName","requestInfo","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groups","RestHandler","GraphQLHandler","graphql","Infinity","hasSameMethod","methodScoreDelta","score","getStringMatchScore","parsedQuery","hasSameOperationType","operationTypeScoreDelta","getScore","suggestedHandlers","suggestions","sort","leftScore","rightScore","strategy","parsedGraphQLQuery","handlerGroups","groupHandlersByType","getSuggestedHandler","getGraphQLHandlerScore","getRestHandlerScore","getSuggestedHandlersMessage","requestHeader","handlerSuggestion","generateHandlerSuggestion","messageTemplate","strategy2","generateUnhandledRequestMessage","warning","applyStrategy","bind","store2","add","persist","handleRequestOptions","onPassthroughResponse","lookupError","lookupResult","until","onUnhandledRequest","readResponseCookies","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","bold","chalk","DEFAULT_LISTEN_OPTIONS","SetupApi","interceptors","interceptor","BatchInterceptor","Interceptor2","resolvedOptions","mockedRequest","arrayBuffer","handleRequest","response3","respondWith","listen","apply","invariant3","InterceptorReadyState","APPLYING","APPLIED","readyState","printHandlers","pragma","hasOwnProperty","close","setupServer","SetupServerApi","ClientRequestInterceptor","XMLHttpRequestInterceptor"],"sources":["C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\config\\polyfills-node.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\node\\SetupServerApi.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\SetupApi.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\devUtils.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\pipeEvents.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\toReadonlyArray.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\isObject.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\mergeRight.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\request\\MockedRequest.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\request\\getRequestCookies.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\jsonParse.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\parseMultipartData.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\request\\parseBody.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\isStringEqual.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\handleRequest.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\getResponse.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\request\\onUnhandledRequest.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\parseGraphQLRequest.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\request\\getPublicUrlFromRequest.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\status.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\set.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\cookie.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\body.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\json.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\data.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\extensions.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\delay.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\errors.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\fetch.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\text.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\xml.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\logging\\getStatusCodeColor.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\logging\\getTimestamp.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\logging\\prepareRequest.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\logging\\prepareResponse.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\matching\\matchRequestUrl.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\url\\cleanUrl.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\url\\isAbsoluteUrl.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\url\\getAbsoluteUrl.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\matching\\normalizePath.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\handlers\\RequestHandler.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\response.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\compose.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\NetworkError.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\getCallFrame.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\isIterable.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\handlers\\RestHandler.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\context\\field.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\internal\\tryCatch.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\handlers\\GraphQLHandler.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\utils\\request\\readResponseCookies.ts","C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\msw\\src\\node\\setupServer.ts"],"sourcesContent":["import { setTimeout as nodeSetTimeout } from 'timers'\n\n// Polyfill the global \"setTimeout\" so MSW could be used\n// with \"jest.useFakeTimers()\". MSW response handling\n// is wrapped in \"setTimeout\", and without this polyfill\n// you'd have to manually advance the timers for the response\n// to finally resolve.\nexport const setTimeout = nodeSetTimeout\n","import chalk from 'chalk'\nimport { invariant } from 'outvariant'\nimport {\n  BatchInterceptor,\n  HttpRequestEventMap,\n  Interceptor,\n  InterceptorReadyState,\n  IsomorphicResponse,\n  MockedResponse as MockedInterceptedResponse,\n} from '@mswjs/interceptors'\nimport { SetupApi } from '../SetupApi'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { handleRequest } from '../utils/handleRequest'\nimport { devUtils } from '../utils/internal/devUtils'\n\n/**\n * @see https://github.com/mswjs/msw/pull/1399\n */\nconst { bold } = chalk\n\nexport type ServerLifecycleEventsMap = LifeCycleEventsMap<IsomorphicResponse>\n\nconst DEFAULT_LISTEN_OPTIONS: RequiredDeep<SharedOptions> = {\n  onUnhandledRequest: 'warn',\n}\n\nexport class SetupServerApi extends SetupApi<ServerLifecycleEventsMap> {\n  protected readonly interceptor: BatchInterceptor<\n    Array<Interceptor<HttpRequestEventMap>>,\n    HttpRequestEventMap\n  >\n  private resolvedOptions: RequiredDeep<SharedOptions>\n\n  constructor(\n    interceptors: Array<{\n      new (): Interceptor<HttpRequestEventMap>\n    }>,\n    ...handlers: Array<RequestHandler>\n  ) {\n    super(...handlers)\n\n    this.interceptor = new BatchInterceptor({\n      name: 'setup-server',\n      interceptors: interceptors.map((Interceptor) => new Interceptor()),\n    })\n    this.resolvedOptions = {} as RequiredDeep<SharedOptions>\n\n    this.init()\n  }\n\n  /**\n   * Subscribe to all requests that are using the interceptor object\n   */\n  private init(): void {\n    this.interceptor.on('request', async (request) => {\n      const mockedRequest = new MockedRequest(request.url, {\n        ...request,\n        body: await request.arrayBuffer(),\n      })\n\n      const response = await handleRequest<\n        MockedInterceptedResponse & { delay?: number }\n      >(\n        mockedRequest,\n        this.currentHandlers,\n        this.resolvedOptions,\n        this.emitter,\n        {\n          transformResponse(response) {\n            return {\n              status: response.status,\n              statusText: response.statusText,\n              headers: response.headers.all(),\n              body: response.body,\n              delay: response.delay,\n            }\n          },\n        },\n      )\n\n      if (response) {\n        // Delay Node.js responses in the listener so that\n        // the response lookup logic is not concerned with responding\n        // in any way. The same delay is implemented in the worker.\n        if (response.delay) {\n          await new Promise((resolve) => {\n            setTimeout(resolve, response.delay)\n          })\n        }\n\n        request.respondWith(response)\n      }\n\n      return\n    })\n\n    this.interceptor.on('response', (request, response) => {\n      if (!request.id) {\n        return\n      }\n\n      if (response.headers.get('x-powered-by') === 'msw') {\n        this.emitter.emit('response:mocked', response, request.id)\n      } else {\n        this.emitter.emit('response:bypass', response, request.id)\n      }\n    })\n  }\n\n  public listen(options: Partial<SharedOptions> = {}): void {\n    this.resolvedOptions = mergeRight(\n      DEFAULT_LISTEN_OPTIONS,\n      options,\n    ) as RequiredDeep<SharedOptions>\n\n    // Apply the interceptor when starting the server.\n    this.interceptor.apply()\n\n    // Assert that the interceptor has been applied successfully.\n    // Also guards us from forgetting to call \"interceptor.apply()\"\n    // as a part of the \"listen\" method.\n    invariant(\n      [InterceptorReadyState.APPLYING, InterceptorReadyState.APPLIED].includes(\n        this.interceptor.readyState,\n      ),\n      devUtils.formatMessage(\n        'Failed to start \"setupServer\": the interceptor failed to apply. This is likely an issue with the library and you should report it at \"%s\".',\n      ),\n      'https://github.com/mswjs/msw/issues/new/choose',\n    )\n  }\n\n  public printHandlers(): void {\n    const handlers = this.listHandlers()\n\n    handlers.forEach((handler) => {\n      const { header, callFrame } = handler.info\n\n      const pragma = handler.info.hasOwnProperty('operationType')\n        ? '[graphql]'\n        : '[rest]'\n\n      console.log(`\\\n${bold(`${pragma} ${header}`)}\n  Declaration: ${callFrame}\n`)\n    })\n  }\n\n  public close(): void {\n    super.dispose()\n    this.interceptor.dispose()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { EventMapType, StrictEventEmitter } from 'strict-event-emitter'\nimport {\n  DefaultBodyType,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n} from './handlers/RequestHandler'\nimport { LifeCycleEventEmitter } from './sharedOptions'\nimport { devUtils } from './utils/internal/devUtils'\nimport { pipeEvents } from './utils/internal/pipeEvents'\nimport { toReadonlyArray } from './utils/internal/toReadonlyArray'\nimport { MockedRequest } from './utils/request/MockedRequest'\n\n/**\n * Generic class for the mock API setup.\n */\nexport abstract class SetupApi<EventsMap extends EventMapType> {\n  protected initialHandlers: ReadonlyArray<RequestHandler>\n  protected currentHandlers: Array<RequestHandler>\n  protected readonly emitter: StrictEventEmitter<EventsMap>\n  protected readonly publicEmitter: StrictEventEmitter<EventsMap>\n\n  public readonly events: LifeCycleEventEmitter<EventsMap>\n\n  constructor(...initialHandlers: Array<RequestHandler>) {\n    this.validateHandlers(...initialHandlers)\n\n    this.initialHandlers = toReadonlyArray(initialHandlers)\n    this.currentHandlers = [...initialHandlers]\n\n    this.emitter = new StrictEventEmitter<EventsMap>()\n    this.publicEmitter = new StrictEventEmitter<EventsMap>()\n    pipeEvents(this.emitter, this.publicEmitter)\n\n    this.events = this.createLifeCycleEvents()\n  }\n\n  private validateHandlers(...handlers: ReadonlyArray<RequestHandler>): void {\n    // Guard against incorrect call signature of the setup API.\n    for (const handler of handlers) {\n      invariant(\n        !Array.isArray(handler),\n        devUtils.formatMessage(\n          'Failed to construct \"%s\" given an Array of request handlers. Make sure you spread the request handlers when calling the respective setup function.',\n        ),\n        this.constructor.name,\n      )\n    }\n  }\n\n  protected dispose(): void {\n    this.emitter.removeAllListeners()\n    this.publicEmitter.removeAllListeners()\n  }\n\n  public use(...runtimeHandlers: Array<RequestHandler>): void {\n    this.currentHandlers.unshift(...runtimeHandlers)\n  }\n\n  public restoreHandlers(): void {\n    this.currentHandlers.forEach((handler) => {\n      handler.markAsSkipped(false)\n    })\n  }\n\n  public resetHandlers(...nextHandlers: Array<RequestHandler>): void {\n    this.currentHandlers =\n      nextHandlers.length > 0 ? [...nextHandlers] : [...this.initialHandlers]\n  }\n\n  public listHandlers(): ReadonlyArray<\n    RequestHandler<\n      RequestHandlerDefaultInfo,\n      MockedRequest<DefaultBodyType>,\n      any,\n      MockedRequest<DefaultBodyType>\n    >\n  > {\n    return toReadonlyArray(this.currentHandlers)\n  }\n\n  private createLifeCycleEvents(): LifeCycleEventEmitter<EventsMap> {\n    return {\n      on: (...args) => {\n        return this.publicEmitter.on(...args)\n      },\n      removeListener: (...args) => {\n        return this.publicEmitter.removeListener(...args)\n      },\n      removeAllListeners: (...args: any) => {\n        return this.publicEmitter.removeAllListeners(...args)\n      },\n    }\n  }\n\n  abstract printHandlers(): void\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { EventEmitter } from 'stream'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents(\n  source: EventEmitter,\n  destination: EventEmitter,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { IsomorphicRequest, RequestInit } from '@mswjs/interceptors'\nimport { decodeBuffer } from '@mswjs/interceptors/lib/utils/bufferUtils.js'\nimport { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from '../../handlers/RequestHandler'\nimport { MockedResponse } from '../../response'\nimport { getRequestCookies } from './getRequestCookies'\nimport { parseBody } from './parseBody'\nimport { isStringEqual } from '../internal/isStringEqual'\n\nexport type RequestCache =\n  | 'default'\n  | 'no-store'\n  | 'reload'\n  | 'no-cache'\n  | 'force-cache'\n  | 'only-if-cached'\n\nexport type RequestMode = 'navigate' | 'same-origin' | 'no-cors' | 'cors'\n\nexport type RequestRedirect = 'follow' | 'error' | 'manual'\n\nexport type RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'frame'\n  | 'iframe'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'xslt'\n  | 'worker'\n\nexport type RequestPriority = 'high' | 'low' | 'auto'\n\nexport type RequestReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url'\n\nexport interface MockedRequestInit extends RequestInit {\n  id?: string\n  cache?: RequestCache\n  redirect?: RequestRedirect\n  integrity?: string\n  keepalive?: boolean\n  mode?: RequestMode\n  priority?: RequestPriority\n  destination?: RequestDestination\n  referrer?: string\n  referrerPolicy?: RequestReferrerPolicy\n  cookies?: Record<string, string>\n}\n\nexport class MockedRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n> extends IsomorphicRequest {\n  public readonly cache: RequestCache\n  public readonly cookies: Record<string, string>\n  public readonly destination: RequestDestination\n  public readonly integrity: string\n  public readonly keepalive: boolean\n  public readonly mode: RequestMode\n  public readonly priority: RequestPriority\n  public readonly redirect: RequestRedirect\n  public readonly referrer: string\n  public readonly referrerPolicy: RequestReferrerPolicy\n\n  constructor(url: URL, init: MockedRequestInit = {}) {\n    super(url, init)\n    if (init.id) {\n      this.id = init.id\n    }\n    this.cache = init.cache || 'default'\n    this.destination = init.destination || ''\n    this.integrity = init.integrity || ''\n    this.keepalive = init.keepalive || false\n    this.mode = init.mode || 'cors'\n    this.priority = init.priority || 'auto'\n    this.redirect = init.redirect || 'follow'\n    this.referrer = init.referrer || ''\n    this.referrerPolicy = init.referrerPolicy || 'no-referrer'\n    this.cookies = init.cookies || this.getCookies()\n  }\n\n  /**\n   * Get parsed request body. The type is inferred from the content type.\n   *\n   * @deprecated - Use `req.text()`, `req.json()` or `req.arrayBuffer()`\n   * to read the request body as a plain text, JSON, or ArrayBuffer.\n   */\n  public get body(): RequestBody {\n    const text = decodeBuffer(this['_body'])\n\n    /**\n     * @deprecated https://github.com/mswjs/msw/issues/1318\n     * @fixme Remove this assumption and let the users read\n     * request body explicitly using \".json()\"/\".text()\"/\".arrayBuffer()\".\n     */\n    // Parse the request's body based on the \"Content-Type\" header.\n    const body = parseBody(text, this.headers)\n\n    if (isStringEqual(this.method, 'GET') && body === '') {\n      return undefined as RequestBody\n    }\n\n    return body as RequestBody\n  }\n\n  /**\n   * Bypass the intercepted request.\n   * This will make a call to the actual endpoint requested.\n   */\n  public passthrough(): MockedResponse<null> {\n    return {\n      // Constructing a dummy \"101 Continue\" mocked response\n      // to keep the return type of the resolver consistent.\n      status: 101,\n      statusText: 'Continue',\n      headers: new Headers(),\n      body: null,\n      // Setting \"passthrough\" to true will signal the response pipeline\n      // to perform this intercepted request as-is.\n      passthrough: true,\n      once: false,\n    }\n  }\n\n  private getCookies(): Record<string, string> {\n    // Parse the cookies passed in the original request \"cookie\" header.\n    const requestCookiesString = this.headers.get('cookie')\n    const ownCookies = requestCookiesString\n      ? cookieUtils.parse(requestCookiesString)\n      : {}\n\n    store.hydrate()\n\n    const cookiesFromStore = Array.from(\n      store.get({ ...this, url: this.url.href })?.entries(),\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value })\n    }, {})\n\n    // Get existing document cookies that are applicable\n    // to this request based on its \"credentials\" policy.\n    const cookiesFromDocument = getRequestCookies(this)\n\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore,\n    }\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append('cookie', `${name}=${value}`)\n    }\n\n    return {\n      ...forwardedCookies,\n      ...ownCookies,\n    }\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from './MockedRequest'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { until } from '@open-draft/until'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { MockedRequest } from './request/MockedRequest'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: StrictEventEmitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  const requiredLookupResult =\n    lookupResult as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as ResponseType)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', request)\n\n  return transformedResponse\n}\n","import { MockedResponse } from '../response'\nimport {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\nimport { MockedRequest } from './request/MockedRequest'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\nimport { MockedRequest } from './MockedRequest'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `   ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport { parse } from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../request/MockedRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from './MockedRequest'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<N>]\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<CookieName>]\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.append('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import type { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess()\n    ? (input, init) =>\n        import('node-fetch').then(({ default: nodeFetch }) =>\n          (nodeFetch as unknown as typeof window.fetch)(input, init),\n        )\n    : window.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import type { DefaultBodyType } from '../../handlers/RequestHandler.js'\nimport type { MockedRequest } from '../request/MockedRequest.js'\n\nexport interface LoggedRequest {\n  id: string\n  url: URL\n  method: string\n  headers: Record<string, string>\n  cookies: Record<string, string>\n  body: DefaultBodyType\n}\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest): LoggedRequest {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<any>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  return {\n    ...res,\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders),\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl.js'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType extends DefaultBodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType extends DefaultBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType extends DefaultBodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType extends DefaultBodyType = any> =\n  ResponseFunction<BodyType> & {\n    /**\n     * Respond using a given mocked response to the first captured request.\n     * Does not affect any subsequent captured requests.\n     */\n    once: ResponseFunction<BodyType>\n    networkError: (message: string) => void\n  }\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType extends DefaultBodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /[\\/\\\\]msw[\\/\\\\]src[\\/\\\\](.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport type { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type ParsedRestRequest = Match\n\nexport class RestRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n  RequestParams extends PathParams = PathParams,\n> extends MockedRequest<RequestBody> {\n  constructor(\n    request: MockedRequest<RequestBody>,\n    public readonly params: RequestParams,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * @deprecated https://github.com/mswjs/msw/issues/1318\n       * @note Use internal request body buffer as the body init\n       * because \"request.body\" is a getter that will trigger\n       * request body parsing at this step.\n       */\n      body: request['_body'],\n    })\n    this.id = request.id\n  }\n}\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return new RestRequest(request, parsedResult.params || {})\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse<any>) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLRequest<\n  Variables extends GraphQLVariables,\n> extends MockedRequest<GraphQLRequestBody<Variables>> {\n  constructor(request: MockedRequest, public readonly variables: Variables) {\n    super(request.url, {\n      ...request,\n      /**\n       * TODO(https://github.com/mswjs/msw/issues/1318): Cleanup\n       */\n      body: request['_body'],\n    })\n  }\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return new GraphQLRequest(request, parsedResult?.variables || {})\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from './MockedRequest'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import { ClientRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/ClientRequest/index.js'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest/index.js'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { SetupServerApi } from './SetupServerApi'\n\n/**\n * Sets up a requests interception in Node.js with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n * @see {@link https://mswjs.io/docs/api/setup-server `setupServer`}\n */\nexport const setupServer = (\n  ...handlers: Array<RequestHandler>\n): SetupServerApi => {\n  return new SetupServerApi(\n    [ClientRequestInterceptor, XMLHttpRequestInterceptor],\n    ...handlers,\n  )\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}