{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeClientRequestArgs = void 0;\nvar debug_1 = require(\"debug\");\nvar http_1 = require(\"http\");\nvar https_1 = require(\"https\");\nvar getRequestOptionsByUrl_1 = require(\"../../../utils/getRequestOptionsByUrl\");\nvar getUrlByRequestOptions_1 = require(\"../../../utils/getUrlByRequestOptions\");\nvar cloneObject_1 = require(\"../../../utils/cloneObject\");\nvar isObject_1 = require(\"../../../utils/isObject\");\nvar log = debug_1.debug('http normalizeClientRequestArgs');\nfunction resolveRequestOptions(args, url) {\n  // Calling `fetch` provides only URL to `ClientRequest`\n  // without any `RequestOptions` or callback.\n  if (typeof args[1] === 'undefined' || typeof args[1] === 'function') {\n    log('request options not provided, deriving from the url', url);\n    return getRequestOptionsByUrl_1.getRequestOptionsByUrl(url);\n  }\n  if (args[1]) {\n    log('has custom RequestOptions!', args[1]);\n    var requestOptionsFromUrl = getRequestOptionsByUrl_1.getRequestOptionsByUrl(url);\n    log('derived RequestOptions from the URL:', requestOptionsFromUrl);\n    /**\n     * Clone the request options to lock their state\n     * at the moment they are provided to `ClientRequest`.\n     * @see https://github.com/mswjs/interceptors/issues/86\n     */\n    log('cloning RequestOptions...');\n    var clonedRequestOptions = cloneObject_1.cloneObject(args[1]);\n    log('successfully cloned RequestOptions!', clonedRequestOptions);\n    return __assign(__assign({}, requestOptionsFromUrl), clonedRequestOptions);\n  }\n  log('using an empty object as request options');\n  return {};\n}\nfunction resolveCallback(args) {\n  return typeof args[1] === 'function' ? args[1] : args[2];\n}\n/**\n * Normalizes parameters given to a `http.request` call\n * so it always has a `URL` and `RequestOptions`.\n */\nfunction normalizeClientRequestArgs(defaultProtocol) {\n  var args = [];\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n  var url;\n  var options;\n  var callback;\n  log('arguments', args);\n  log('using default protocol:', defaultProtocol);\n  // Convert a url string into a URL instance\n  // and derive request options from it.\n  if (typeof args[0] === 'string') {\n    log('first argument is a location string:', args[0]);\n    url = new URL(args[0]);\n    log('created a url:', url);\n    var requestOptionsFromUrl = getRequestOptionsByUrl_1.getRequestOptionsByUrl(url);\n    log('request options from url:', requestOptionsFromUrl);\n    options = resolveRequestOptions(args, url);\n    log('resolved request options:', options);\n    callback = resolveCallback(args);\n  }\n  // Handle a given URL instance as-is\n  // and derive request options from it.\n  else if (args[0] instanceof URL) {\n    url = args[0];\n    log('first argument is a URL:', url);\n    options = resolveRequestOptions(args, url);\n    log('derived request options:', options);\n    callback = resolveCallback(args);\n  }\n  // Handle a legacy URL instance and re-normalize from either a RequestOptions object\n  // or a WHATWG URL.\n  else if ('hash' in args[0] && !('method' in args[0])) {\n    var _a = __read(args, 1),\n      legacyUrl = _a[0];\n    log('first argument is a legacy URL:', legacyUrl);\n    if (legacyUrl.hostname === null) {\n      /**\n       * We are dealing with a relative url, so use the path as an \"option\" and\n       * merge in any existing options, giving priority to exising options -- i.e. a path in any\n       * existing options will take precedence over the one contained in the url. This is consistent\n       * with the behaviour in ClientRequest.\n       * @see https://github.com/nodejs/node/blob/d84f1312915fe45fe0febe888db692c74894c382/lib/_http_client.js#L122\n       */\n      log('given legacy URL is relative (no hostname)');\n      return isObject_1.isObject(args[1]) ? normalizeClientRequestArgs(defaultProtocol, __assign({\n        path: legacyUrl.path\n      }, args[1]), args[2]) : normalizeClientRequestArgs(defaultProtocol, {\n        path: legacyUrl.path\n      }, args[1]);\n    }\n    log('given legacy url is absolute');\n    // We are dealing with an absolute URL, so convert to WHATWG and try again.\n    var resolvedUrl = new URL(legacyUrl.href);\n    return args[1] === undefined ? normalizeClientRequestArgs(defaultProtocol, resolvedUrl) : typeof args[1] === 'function' ? normalizeClientRequestArgs(defaultProtocol, resolvedUrl, args[1]) : normalizeClientRequestArgs(defaultProtocol, resolvedUrl, args[1], args[2]);\n  }\n  // Handle a given \"RequestOptions\" object as-is\n  // and derive the URL instance from it.\n  else if (isObject_1.isObject(args[0])) {\n    options = args[0];\n    log('first argument is RequestOptions:', options);\n    // When handling a \"RequestOptions\" object without an explicit \"protocol\",\n    // infer the protocol from the request issuing module (http/https).\n    options.protocol = options.protocol || defaultProtocol;\n    log('normalized request options:', options);\n    url = getUrlByRequestOptions_1.getUrlByRequestOptions(options);\n    log('created a URL from RequestOptions:', url.href);\n    callback = resolveCallback(args);\n  } else {\n    throw new Error(\"Failed to construct ClientRequest with these parameters: \" + args);\n  }\n  options.protocol = options.protocol || url.protocol;\n  options.method = options.method || 'GET';\n  /**\n   * Infer a fallback agent from the URL protocol.\n   * The interception is done on the \"ClientRequest\" level (\"NodeClientRequest\")\n   * and it may miss the correct agent. Always align the agent\n   * with the URL protocol, if not provided.\n   *\n   * @note Respect the \"agent: false\" value.\n   */\n  if (typeof options.agent === 'undefined') {\n    var agent = options.protocol === 'https:' ? new https_1.Agent({\n      rejectUnauthorized: options.rejectUnauthorized\n    }) : new http_1.Agent();\n    options.agent = agent;\n    log('resolved fallback agent:', agent);\n  }\n  /**\n   * Ensure that the default Agent is always set.\n   * This prevents the protocol mismatch for requests with { agent: false },\n   * where the global Agent is inferred.\n   * @see https://github.com/mswjs/msw/issues/1150\n   * @see https://github.com/nodejs/node/blob/418ff70b810f0e7112d48baaa72932a56cfa213b/lib/_http_client.js#L130\n   * @see https://github.com/nodejs/node/blob/418ff70b810f0e7112d48baaa72932a56cfa213b/lib/_http_client.js#L157-L159\n   */\n  if (!options._defaultAgent) {\n    log('has no default agent, setting the default agent for \"%s\"', options.protocol);\n    options._defaultAgent = options.protocol === 'https:' ? https_1.globalAgent : http_1.globalAgent;\n  }\n  log('successfully resolved url:', url.href);\n  log('successfully resolved options:', options);\n  log('successfully resolved callback:', callback);\n  return [url, options, callback];\n}\nexports.normalizeClientRequestArgs = normalizeClientRequestArgs;","map":{"version":3,"mappings":"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","names":["log","debug_1","resolveRequestOptions","args","url","getRequestOptionsByUrl_1","requestOptionsFromUrl","clonedRequestOptions","cloneObject_1","resolveCallback","normalizeClientRequestArgs","defaultProtocol","_i","options","callback","URL","legacyUrl","hostname","isObject_1","path","resolvedUrl","href","undefined","protocol","getUrlByRequestOptions_1","Error","method","agent","https_1","rejectUnauthorized","http_1","_defaultAgent","exports"],"sources":["C:\\Users\\Gregory Santosa\\Desktop\\Fall2022HW\\personal\\cse186\\Assignment8\\frontend\\node_modules\\@mswjs\\interceptors\\src\\interceptors\\ClientRequest\\utils\\normalizeClientRequestArgs.ts"],"sourcesContent":["import { debug } from 'debug'\nimport {\n  Agent as HttpAgent,\n  globalAgent as httpGlobalAgent,\n  IncomingMessage,\n} from 'http'\nimport {\n  RequestOptions,\n  Agent as HttpsAgent,\n  globalAgent as httpsGlobalAgent,\n} from 'https'\nimport { Url as LegacyURL } from 'url'\nimport { getRequestOptionsByUrl } from '../../../utils/getRequestOptionsByUrl'\nimport {\n  ResolvedRequestOptions,\n  getUrlByRequestOptions,\n} from '../../../utils/getUrlByRequestOptions'\nimport { cloneObject } from '../../../utils/cloneObject'\nimport { isObject } from '../../../utils/isObject'\n\nconst log = debug('http normalizeClientRequestArgs')\n\nexport type HttpRequestCallback = (response: IncomingMessage) => void\n\nexport type ClientRequestArgs =\n  | [string | URL | LegacyURL, HttpRequestCallback?]\n  | [string | URL | LegacyURL, RequestOptions, HttpRequestCallback?]\n  | [RequestOptions, HttpRequestCallback?]\n\nfunction resolveRequestOptions(\n  args: ClientRequestArgs,\n  url: URL\n): RequestOptions {\n  // Calling `fetch` provides only URL to `ClientRequest`\n  // without any `RequestOptions` or callback.\n  if (typeof args[1] === 'undefined' || typeof args[1] === 'function') {\n    log('request options not provided, deriving from the url', url)\n    return getRequestOptionsByUrl(url)\n  }\n\n  if (args[1]) {\n    log('has custom RequestOptions!', args[1])\n    const requestOptionsFromUrl = getRequestOptionsByUrl(url)\n\n    log('derived RequestOptions from the URL:', requestOptionsFromUrl)\n\n    /**\n     * Clone the request options to lock their state\n     * at the moment they are provided to `ClientRequest`.\n     * @see https://github.com/mswjs/interceptors/issues/86\n     */\n    log('cloning RequestOptions...')\n    const clonedRequestOptions = cloneObject(args[1])\n    log('successfully cloned RequestOptions!', clonedRequestOptions)\n\n    return {\n      ...requestOptionsFromUrl,\n      ...clonedRequestOptions,\n    }\n  }\n\n  log('using an empty object as request options')\n  return {} as RequestOptions\n}\n\nfunction resolveCallback(\n  args: ClientRequestArgs\n): HttpRequestCallback | undefined {\n  return typeof args[1] === 'function' ? args[1] : args[2]\n}\n\nexport type NormalizedClientRequestArgs = [\n  url: URL,\n  options: ResolvedRequestOptions,\n  callback?: HttpRequestCallback\n]\n\n/**\n * Normalizes parameters given to a `http.request` call\n * so it always has a `URL` and `RequestOptions`.\n */\nexport function normalizeClientRequestArgs(\n  defaultProtocol: string,\n  ...args: ClientRequestArgs\n): NormalizedClientRequestArgs {\n  let url: URL\n  let options: ResolvedRequestOptions\n  let callback: HttpRequestCallback | undefined\n\n  log('arguments', args)\n  log('using default protocol:', defaultProtocol)\n\n  // Convert a url string into a URL instance\n  // and derive request options from it.\n  if (typeof args[0] === 'string') {\n    log('first argument is a location string:', args[0])\n\n    url = new URL(args[0])\n    log('created a url:', url)\n\n    const requestOptionsFromUrl = getRequestOptionsByUrl(url)\n    log('request options from url:', requestOptionsFromUrl)\n\n    options = resolveRequestOptions(args, url)\n    log('resolved request options:', options)\n\n    callback = resolveCallback(args)\n  }\n  // Handle a given URL instance as-is\n  // and derive request options from it.\n  else if (args[0] instanceof URL) {\n    url = args[0]\n    log('first argument is a URL:', url)\n\n    options = resolveRequestOptions(args, url)\n    log('derived request options:', options)\n\n    callback = resolveCallback(args)\n  }\n  // Handle a legacy URL instance and re-normalize from either a RequestOptions object\n  // or a WHATWG URL.\n  else if ('hash' in args[0] && !('method' in args[0])) {\n    const [legacyUrl] = args\n    log('first argument is a legacy URL:', legacyUrl)\n\n    if (legacyUrl.hostname === null) {\n      /**\n       * We are dealing with a relative url, so use the path as an \"option\" and\n       * merge in any existing options, giving priority to exising options -- i.e. a path in any\n       * existing options will take precedence over the one contained in the url. This is consistent\n       * with the behaviour in ClientRequest.\n       * @see https://github.com/nodejs/node/blob/d84f1312915fe45fe0febe888db692c74894c382/lib/_http_client.js#L122\n       */\n      log('given legacy URL is relative (no hostname)')\n\n      return isObject(args[1])\n        ? normalizeClientRequestArgs(\n            defaultProtocol,\n            { path: legacyUrl.path, ...args[1] },\n            args[2]\n          )\n        : normalizeClientRequestArgs(\n            defaultProtocol,\n            { path: legacyUrl.path },\n            args[1] as HttpRequestCallback\n          )\n    }\n\n    log('given legacy url is absolute')\n\n    // We are dealing with an absolute URL, so convert to WHATWG and try again.\n    const resolvedUrl = new URL(legacyUrl.href)\n\n    return args[1] === undefined\n      ? normalizeClientRequestArgs(defaultProtocol, resolvedUrl)\n      : typeof args[1] === 'function'\n      ? normalizeClientRequestArgs(defaultProtocol, resolvedUrl, args[1])\n      : normalizeClientRequestArgs(\n          defaultProtocol,\n          resolvedUrl,\n          args[1],\n          args[2]\n        )\n  }\n  // Handle a given \"RequestOptions\" object as-is\n  // and derive the URL instance from it.\n  else if (isObject(args[0])) {\n    options = args[0]\n    log('first argument is RequestOptions:', options)\n\n    // When handling a \"RequestOptions\" object without an explicit \"protocol\",\n    // infer the protocol from the request issuing module (http/https).\n    options.protocol = options.protocol || defaultProtocol\n    log('normalized request options:', options)\n\n    url = getUrlByRequestOptions(options)\n    log('created a URL from RequestOptions:', url.href)\n\n    callback = resolveCallback(args)\n  } else {\n    throw new Error(\n      `Failed to construct ClientRequest with these parameters: ${args}`\n    )\n  }\n\n  options.protocol = options.protocol || url.protocol\n  options.method = options.method || 'GET'\n\n  /**\n   * Infer a fallback agent from the URL protocol.\n   * The interception is done on the \"ClientRequest\" level (\"NodeClientRequest\")\n   * and it may miss the correct agent. Always align the agent\n   * with the URL protocol, if not provided.\n   *\n   * @note Respect the \"agent: false\" value.\n   */\n  if (typeof options.agent === 'undefined') {\n    const agent =\n      options.protocol === 'https:'\n        ? new HttpsAgent({\n            rejectUnauthorized: options.rejectUnauthorized,\n          })\n        : new HttpAgent()\n\n    options.agent = agent\n    log('resolved fallback agent:', agent)\n  }\n\n  /**\n   * Ensure that the default Agent is always set.\n   * This prevents the protocol mismatch for requests with { agent: false },\n   * where the global Agent is inferred.\n   * @see https://github.com/mswjs/msw/issues/1150\n   * @see https://github.com/nodejs/node/blob/418ff70b810f0e7112d48baaa72932a56cfa213b/lib/_http_client.js#L130\n   * @see https://github.com/nodejs/node/blob/418ff70b810f0e7112d48baaa72932a56cfa213b/lib/_http_client.js#L157-L159\n   */\n  if (!options._defaultAgent) {\n    log(\n      'has no default agent, setting the default agent for \"%s\"',\n      options.protocol\n    )\n\n    options._defaultAgent =\n      options.protocol === 'https:' ? httpsGlobalAgent : httpGlobalAgent\n  }\n\n  log('successfully resolved url:', url.href)\n  log('successfully resolved options:', options)\n  log('successfully resolved callback:', callback)\n\n  return [url, options, callback]\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}